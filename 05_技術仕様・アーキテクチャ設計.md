# トラック配送計画・配送実績追跡システム - 技術仕様・アーキテクチャ設計

## 1. システムアーキテクチャ概要

### 1.1 全体構成図

```
┌─────────────────────────────────────────────────────────┐
│                     クライアント層                       │
├─────────────────────────────────────────────────────────┤
│  Webブラウザ              モバイルアプリ                 │
│  (React SPA)             (React Native)                 │
│  - 配車担当者用          - ドライバー用                  │
│  - 管理者用              - iOS / Android                │
└───────────────┬─────────────────┬───────────────────────┘
                │                 │
            HTTPS/REST        HTTPS/REST
                │                 │
┌───────────────┴─────────────────┴───────────────────────┐
│                     API層                                │
├─────────────────────────────────────────────────────────┤
│  API Gateway (AWS API Gateway / Azure API Management)   │
│  - 認証・認可 (JWT)                                      │
│  - レート制限                                            │
│  - ログ・監視                                            │
└───────────────┬─────────────────────────────────────────┘
                │
┌───────────────┴─────────────────────────────────────────┐
│                  アプリケーション層                       │
├─────────────────────────────────────────────────────────┤
│  Webアプリケーションサーバー (Node.js / Express)         │
│  ┌─────────────────────────────────────────────────┐   │
│  │  ビジネスロジック                                │   │
│  │  - 配送計画管理サービス                          │   │
│  │  - 配送実績管理サービス                          │   │
│  │  - ルート最適化サービス                          │   │
│  │  - 位置追跡サービス                              │   │
│  │  - 通知サービス                                  │   │
│  │  - レポート生成サービス                          │   │
│  └─────────────────────────────────────────────────┘   │
└───────────────┬─────────────────────────────────────────┘
                │
┌───────────────┴─────────────────────────────────────────┐
│                    データ層                              │
├─────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌─────────────┐  │
│  │ RDB          │  │ NoSQL        │  │ キャッシュ  │  │
│  │ (PostgreSQL) │  │ (MongoDB)    │  │ (Redis)     │  │
│  │ - マスタ     │  │ - 位置履歴   │  │ - セッション│  │
│  │ - トランザク │  │ - ログ       │  │ - 一時データ│  │
│  └──────────────┘  └──────────────┘  └─────────────┘  │
│                                                         │
│  ┌──────────────┐  ┌──────────────┐                   │
│  │ オブジェクト │  │ キューイング │                   │
│  │ ストレージ   │  │ (RabbitMQ)   │                   │
│  │ (S3/Blob)    │  │ - 非同期処理 │                   │
│  │ - 画像       │  │ - イベント   │                   │
│  └──────────────┘  └──────────────┘                   │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│                  外部サービス層                          │
├─────────────────────────────────────────────────────────┤
│  - Google Maps API (地図・ルート検索)                    │
│  - GPS/テレマティクスサービス                            │
│  - メール送信サービス (SendGrid / SES)                   │
│  - プッシュ通知 (Firebase Cloud Messaging)               │
│  - SMS送信 (Twilio)                                      │
└─────────────────────────────────────────────────────────┘
```

### 1.2 技術スタック

#### フロントエンド（Web）
```
フレームワーク: React 18.x
状態管理: Redux Toolkit / Zustand
UIライブラリ: Material-UI (MUI) v5
地図表示: Google Maps JavaScript API / Leaflet
チャート: Recharts / Chart.js
フォーム: React Hook Form + Yup
HTTP通信: Axios
ビルドツール: Vite
言語: TypeScript 5.x
```

#### フロントエンド（モバイル）
```
フレームワーク: React Native 0.73.x
ナビゲーション: React Navigation 6.x
状態管理: Redux Toolkit
UIコンポーネント: React Native Paper
地図: react-native-maps
カメラ: react-native-vision-camera
位置情報: react-native-geolocation-service
オフライン: WatermelonDB / Realm
言語: TypeScript 5.x
```

#### バックエンド
```
ランタイム: Node.js 20.x LTS
フレームワーク: Express.js 4.x / NestJS 10.x
ORM: Prisma 5.x / TypeORM
認証: Passport.js + JWT
バリデーション: Joi / class-validator
ロギング: Winston
API仕様: OpenAPI 3.0 (Swagger)
言語: TypeScript 5.x
```

#### データベース
```
RDB: PostgreSQL 16.x
  - 拡張: PostGIS (地理空間データ)
NoSQL: MongoDB 7.x
  - 位置履歴・ログデータ
キャッシュ: Redis 7.x
  - セッション管理
  - リアルタイムデータ
```

#### インフラ・DevOps
```
クラウド: AWS / Azure (選択可能)
コンテナ: Docker + Kubernetes (EKS / AKS)
CI/CD: GitHub Actions / GitLab CI
監視: Datadog / New Relic / CloudWatch
ログ: ELK Stack (Elasticsearch, Logstash, Kibana)
IaC: Terraform / AWS CDK
```

## 2. データベース設計

### 2.1 PostgreSQL（メインDB）

**接続設定**
```typescript
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [postgis]
}

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}
```

**インデックス戦略**
```sql
-- 配送依頼検索用
CREATE INDEX idx_delivery_order_date ON delivery_order(requested_delivery_date, status);
CREATE INDEX idx_delivery_order_customer ON delivery_order(customer_id);

-- 配送ルート検索用
CREATE INDEX idx_delivery_route_plan ON delivery_route(delivery_plan_id, status);
CREATE INDEX idx_delivery_route_driver ON delivery_route(driver_id, scheduled_departure_time);

-- 位置情報検索用（PostGIS）
CREATE INDEX idx_delivery_location_geo ON delivery_location USING GIST(ST_MakePoint(longitude, latitude));

-- 配送実績検索用
CREATE INDEX idx_delivery_execution_date ON delivery_execution(delivery_date, delivery_result);
```

**パーティショニング**
```sql
-- 位置履歴テーブル（月次パーティション）
CREATE TABLE tracking_history (
    history_id VARCHAR(20) PRIMARY KEY,
    vehicle_id VARCHAR(20) NOT NULL,
    recorded_at TIMESTAMP NOT NULL,
    -- 他のカラム
) PARTITION BY RANGE (recorded_at);

CREATE TABLE tracking_history_2025_01 PARTITION OF tracking_history
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE tracking_history_2025_02 PARTITION OF tracking_history
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
```

### 2.2 MongoDB（ログ・履歴DB）

**コレクション設計**
```javascript
// tracking_logs コレクション
{
  _id: ObjectId,
  vehicle_id: "V-001",
  route_id: "R-001",
  timestamp: ISODate("2025-01-20T10:30:00Z"),
  location: {
    type: "Point",
    coordinates: [139.6917, 35.6895] // [経度, 緯度]
  },
  speed: 45.5,
  heading: 270,
  accuracy: 10,
  status: "MOVING"
}

// インデックス
db.tracking_logs.createIndex({ vehicle_id: 1, timestamp: -1 });
db.tracking_logs.createIndex({ location: "2dsphere" });
db.tracking_logs.createIndex({ timestamp: 1 }, { expireAfterSeconds: 31536000 }); // 1年後自動削除
```

### 2.3 Redis（キャッシュ）

**データ構造**
```
# セッション管理
session:<session_id> -> JSON (TTL: 24時間)

# リアルタイム車両位置
vehicle:location:<vehicle_id> -> JSON (TTL: 10分)

# 配送進捗キャッシュ
route:progress:<route_id> -> JSON (TTL: 5分)

# レート制限
ratelimit:<user_id>:<endpoint> -> カウント (TTL: 1分)
```

## 3. API設計

### 3.1 REST API エンドポイント

**認証**
```
POST   /api/v1/auth/login          ログイン
POST   /api/v1/auth/logout         ログアウト
POST   /api/v1/auth/refresh        トークン更新
GET    /api/v1/auth/me             ユーザー情報取得
```

**配送依頼**
```
GET    /api/v1/delivery-orders                 配送依頼一覧
GET    /api/v1/delivery-orders/:id             配送依頼詳細
POST   /api/v1/delivery-orders                 配送依頼登録
PUT    /api/v1/delivery-orders/:id             配送依頼更新
DELETE /api/v1/delivery-orders/:id             配送依頼削除
POST   /api/v1/delivery-orders/import          CSVインポート
GET    /api/v1/delivery-orders/export          CSVエクスポート
```

**配車計画**
```
GET    /api/v1/delivery-plans                  配車計画一覧
GET    /api/v1/delivery-plans/:id              配車計画詳細
POST   /api/v1/delivery-plans                  配車計画作成
PUT    /api/v1/delivery-plans/:id              配車計画更新
POST   /api/v1/delivery-plans/:id/confirm      配車計画確定
DELETE /api/v1/delivery-plans/:id              配車計画削除
```

**配送ルート**
```
GET    /api/v1/delivery-routes                 配送ルート一覧
GET    /api/v1/delivery-routes/:id             配送ルート詳細
POST   /api/v1/delivery-routes                 配送ルート作成
PUT    /api/v1/delivery-routes/:id             配送ルート更新
POST   /api/v1/delivery-routes/:id/optimize    ルート最適化
GET    /api/v1/delivery-routes/:id/tracking    リアルタイム追跡
```

**配送実績**
```
GET    /api/v1/delivery-executions             配送実績一覧
GET    /api/v1/delivery-executions/:id         配送実績詳細
POST   /api/v1/delivery-executions             配送実績登録
PUT    /api/v1/delivery-executions/:id         配送実績更新
POST   /api/v1/delivery-executions/:id/proof   配送証跡アップロード
```

**車両追跡**
```
GET    /api/v1/tracking/vehicles               全車両位置取得
GET    /api/v1/tracking/vehicles/:id           車両位置取得
POST   /api/v1/tracking/vehicles/:id/location  位置情報更新
GET    /api/v1/tracking/history/:vehicle_id    位置履歴取得
```

**マスタ管理**
```
GET    /api/v1/vehicles                        車両一覧
POST   /api/v1/vehicles                        車両登録
PUT    /api/v1/vehicles/:id                    車両更新
DELETE /api/v1/vehicles/:id                    車両削除

GET    /api/v1/drivers                         ドライバー一覧
POST   /api/v1/drivers                         ドライバー登録
PUT    /api/v1/drivers/:id                     ドライバー更新
DELETE /api/v1/drivers/:id                     ドライバー削除

GET    /api/v1/customers                       顧客一覧
POST   /api/v1/customers                       顧客登録
PUT    /api/v1/customers/:id                   顧客更新
DELETE /api/v1/customers/:id                   顧客削除
```

**レポート・分析**
```
GET    /api/v1/reports/daily                   日次レポート
GET    /api/v1/reports/monthly                 月次レポート
GET    /api/v1/dashboards/kpi                  KPIダッシュボード
GET    /api/v1/analytics/performance           実績分析
```

### 3.2 WebSocket API

**リアルタイム更新**
```
接続: ws://api.example.com/ws

// クライアント → サーバー
{
  "action": "subscribe",
  "channel": "vehicle-location",
  "vehicle_ids": ["V-001", "V-002"]
}

// サーバー → クライアント
{
  "channel": "vehicle-location",
  "data": {
    "vehicle_id": "V-001",
    "latitude": 35.6895,
    "longitude": 139.6917,
    "speed": 45.5,
    "timestamp": "2025-01-20T10:30:00Z"
  }
}
```

### 3.3 認証・認可

**JWT構造**
```json
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "user_id": "U-001",
    "login_id": "dispatcher01",
    "role": "DISPATCHER",
    "branch_id": "B-001",
    "exp": 1642694400,
    "iat": 1642608000
  }
}
```

**権限マトリクス**
```
機能                     | ADMIN | DISPATCHER | DRIVER
------------------------|-------|------------|--------
配送依頼登録            |   ✓   |     ✓      |   ×
配車計画作成            |   ✓   |     ✓      |   ×
配送実績入力（自分）    |   ✓   |     ×      |   ✓
配送実績閲覧（全体）    |   ✓   |     ✓      |   ×
マスタ管理              |   ✓   |     ×      |   ×
レポート閲覧            |   ✓   |     ✓      |   ×
```

## 4. バックエンドアーキテクチャ

### 4.1 レイヤードアーキテクチャ

```
┌─────────────────────────────────┐
│     Presentation Layer          │
│  (Controllers / Routes)         │
│  - リクエスト受付                │
│  - レスポンス生成                │
│  - バリデーション                │
└────────────┬────────────────────┘
             │
┌────────────┴────────────────────┐
│     Application Layer           │
│  (Services / Use Cases)         │
│  - ビジネスロジック              │
│  - トランザクション管理          │
│  - 外部サービス連携              │
└────────────┬────────────────────┘
             │
┌────────────┴────────────────────┐
│     Domain Layer                │
│  (Entities / Value Objects)     │
│  - ドメインモデル                │
│  - ビジネスルール                │
└────────────┬────────────────────┘
             │
┌────────────┴────────────────────┐
│     Infrastructure Layer        │
│  (Repositories / Data Access)   │
│  - データベースアクセス          │
│  - 外部API呼び出し               │
└─────────────────────────────────┘
```

### 4.2 ディレクトリ構成

```
backend/
├── src/
│   ├── modules/
│   │   ├── auth/
│   │   │   ├── auth.controller.ts
│   │   │   ├── auth.service.ts
│   │   │   ├── auth.module.ts
│   │   │   └── dto/
│   │   ├── delivery-order/
│   │   │   ├── delivery-order.controller.ts
│   │   │   ├── delivery-order.service.ts
│   │   │   ├── delivery-order.repository.ts
│   │   │   ├── delivery-order.entity.ts
│   │   │   └── dto/
│   │   ├── delivery-route/
│   │   ├── tracking/
│   │   └── report/
│   ├── common/
│   │   ├── guards/
│   │   ├── interceptors/
│   │   ├── filters/
│   │   ├── decorators/
│   │   └── utils/
│   ├── config/
│   │   ├── database.config.ts
│   │   ├── redis.config.ts
│   │   └── app.config.ts
│   └── main.ts
├── prisma/
│   ├── schema.prisma
│   ├── migrations/
│   └── seed.ts
├── test/
├── docker/
├── package.json
└── tsconfig.json
```

### 4.3 主要サービス実装例

**配送ルート最適化サービス**
```typescript
// delivery-route/route-optimizer.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class RouteOptimizerService {
  /**
   * 2-opt法によるルート最適化
   */
  async optimize(route: DeliveryRoute): Promise<OptimizationResult> {
    const stops = route.stops;
    let currentRoute = [...stops];
    let bestDistance = this.calculateTotalDistance(currentRoute);
    let improved = true;

    // 最大反復回数
    const maxIterations = 1000;
    let iteration = 0;

    while (improved && iteration < maxIterations) {
      improved = false;

      for (let i = 1; i < currentRoute.length - 1; i++) {
        for (let j = i + 1; j < currentRoute.length; j++) {
          // 2点を入れ替えた新しいルートを生成
          const newRoute = this.swap2Opt(currentRoute, i, j);
          
          // 制約チェック
          if (!this.checkConstraints(newRoute, route.vehicle)) {
            continue;
          }

          const newDistance = this.calculateTotalDistance(newRoute);

          if (newDistance < bestDistance) {
            currentRoute = newRoute;
            bestDistance = newDistance;
            improved = true;
          }
        }
      }
      iteration++;
    }

    return {
      optimizedStops: currentRoute,
      beforeDistance: this.calculateTotalDistance(stops),
      afterDistance: bestDistance,
      improvementRate: ((bestDistance - this.calculateTotalDistance(stops)) / this.calculateTotalDistance(stops)) * 100,
      iterations: iteration
    };
  }

  private swap2Opt(route: RouteStop[], i: number, j: number): RouteStop[] {
    const newRoute = [...route];
    // i から j までを逆順にする
    while (i < j) {
      [newRoute[i], newRoute[j]] = [newRoute[j], newRoute[i]];
      i++;
      j--;
    }
    return newRoute;
  }

  private async calculateTotalDistance(stops: RouteStop[]): Promise<number> {
    let totalDistance = 0;
    for (let i = 0; i < stops.length - 1; i++) {
      const distance = await this.getDistance(stops[i], stops[i + 1]);
      totalDistance += distance;
    }
    return totalDistance;
  }

  private async getDistance(from: RouteStop, to: RouteStop): Promise<number> {
    // Google Maps Distance Matrix API呼び出し
    // またはハーバーサイン公式による直線距離計算
    return this.haversineDistance(
      from.location.latitude,
      from.location.longitude,
      to.location.latitude,
      to.location.longitude
    );
  }

  private haversineDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
    const R = 6371; // 地球の半径(km)
    const dLat = this.toRad(lat2 - lat1);
    const dLon = this.toRad(lon2 - lon1);
    const a = 
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) *
      Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  private toRad(degrees: number): number {
    return degrees * (Math.PI / 180);
  }

  private checkConstraints(route: RouteStop[], vehicle: Vehicle): boolean {
    // 積載容量チェック
    const totalWeight = route.reduce((sum, stop) => sum + stop.weight, 0);
    if (totalWeight > vehicle.maxLoadWeight) return false;

    // 時間指定チェック
    for (const stop of route) {
      if (stop.specifiedTimeFrom && stop.estimatedArrival < stop.specifiedTimeFrom) {
        return false;
      }
      if (stop.specifiedTimeTo && stop.estimatedArrival > stop.specifiedTimeTo) {
        return false;
      }
    }

    return true;
  }
}
```

**位置追跡サービス**
```typescript
// tracking/tracking.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRedis } from '@nestjs-modules/ioredis';
import Redis from 'ioredis';

@Injectable()
export class TrackingService {
  constructor(
    @InjectRedis() private readonly redis: Redis,
    private readonly trackingRepository: TrackingRepository,
  ) {}

  /**
   * 車両位置更新
   */
  async updateVehicleLocation(vehicleId: string, location: LocationData): Promise<void> {
    // Redisに最新位置を保存（TTL: 10分）
    await this.redis.setex(
      `vehicle:location:${vehicleId}`,
      600,
      JSON.stringify({
        latitude: location.latitude,
        longitude: location.longitude,
        speed: location.speed,
        heading: location.heading,
        timestamp: location.timestamp,
      })
    );

    // MongoDBに履歴を保存
    await this.trackingRepository.insertHistory({
      vehicle_id: vehicleId,
      location: {
        type: 'Point',
        coordinates: [location.longitude, location.latitude],
      },
      speed: location.speed,
      heading: location.heading,
      recorded_at: location.timestamp,
    });

    // WebSocketで配信
    this.broadcastLocationUpdate(vehicleId, location);
  }

  /**
   * 遅延検知
   */
  async detectDelay(routeId: string): Promise<DelayInfo | null> {
    const route = await this.routeRepository.findById(routeId);
    const currentStop = route.stops.find(s => s.status === 'PENDING');
    
    if (!currentStop) return null;

    const vehicleLocation = await this.getVehicleLocation(route.vehicleId);
    const distanceToStop = this.calculateDistance(
      vehicleLocation,
      currentStop.location
    );

    // 平均速度から到着予想時刻を計算
    const avgSpeed = 30; // km/h
    const estimatedTimeMinutes = (distanceToStop / avgSpeed) * 60;
    const estimatedArrival = new Date(Date.now() + estimatedTimeMinutes * 60000);

    const scheduledArrival = new Date(currentStop.scheduledArrivalTime);
    const delayMinutes = (estimatedArrival.getTime() - scheduledArrival.getTime()) / 60000;

    if (delayMinutes > 15) {
      // 15分以上の遅延
      return {
        routeId,
        stopId: currentStop.id,
        delayMinutes: Math.round(delayMinutes),
        estimatedArrival,
        scheduledArrival,
      };
    }

    return null;
  }
}
```

## 5. フロントエンド設計

### 5.1 状態管理（Redux Toolkit）

**Store構成**
```typescript
// store/index.ts
import { configureStore } from '@reduxjs/toolkit';
import authReducer from './slices/authSlice';
import deliveryOrderReducer from './slices/deliveryOrderSlice';
import deliveryRouteReducer from './slices/deliveryRouteSlice';
import trackingReducer from './slices/trackingSlice';

export const store = configureStore({
  reducer: {
    auth: authReducer,
    deliveryOrder: deliveryOrderReducer,
    deliveryRoute: deliveryRouteReducer,
    tracking: trackingReducer,
  },
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

**Slice例**
```typescript
// store/slices/deliveryOrderSlice.ts
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

export const fetchDeliveryOrders = createAsyncThunk(
  'deliveryOrder/fetchAll',
  async (params: SearchParams) => {
    const response = await api.get('/delivery-orders', { params });
    return response.data;
  }
);

const deliveryOrderSlice = createSlice({
  name: 'deliveryOrder',
  initialState: {
    orders: [],
    loading: false,
    error: null,
    pagination: { page: 1, perPage: 25, total: 0 },
  },
  reducers: {
    setPage: (state, action) => {
      state.pagination.page = action.payload;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchDeliveryOrders.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchDeliveryOrders.fulfilled, (state, action) => {
        state.loading = false;
        state.orders = action.payload.data;
        state.pagination = action.payload.pagination;
      })
      .addCase(fetchDeliveryOrders.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  },
});

export const { setPage } = deliveryOrderSlice.actions;
export default deliveryOrderSlice.reducer;
```

### 5.2 コンポーネント設計

**Atomic Design適用**
```
src/
├── components/
│   ├── atoms/
│   │   ├── Button/
│   │   ├── Input/
│   │   ├── Label/
│   │   └── Icon/
│   ├── molecules/
│   │   ├── FormField/
│   │   ├── SearchBox/
│   │   └── StatusBadge/
│   ├── organisms/
│   │   ├── DeliveryOrderTable/
│   │   ├── RouteMap/
│   │   └── KPICard/
│   ├── templates/
│   │   ├── DashboardLayout/
│   │   └── FormLayout/
│   └── pages/
│       ├── DeliveryOrderList/
│       ├── RoutePlanning/
│       └── TrackingMonitor/
```

**コンポーネント例**
```typescript
// components/organisms/RouteMap/RouteMap.tsx
import React, { useEffect, useRef } from 'react';
import { GoogleMap, Marker, Polyline } from '@react-google-maps/api';

interface RouteMapProps {
  vehicles: Vehicle[];
  routes: DeliveryRoute[];
  onVehicleClick?: (vehicleId: string) => void;
}

export const RouteMap: React.FC<RouteMapProps> = ({ vehicles, routes, onVehicleClick }) => {
  const mapRef = useRef<google.maps.Map>();

  const mapOptions = {
    zoom: 12,
    center: { lat: 35.6895, lng: 139.6917 },
  };

  return (
    <GoogleMap
      mapContainerStyle={{ width: '100%', height: '600px' }}
      options={mapOptions}
      onLoad={(map) => { mapRef.current = map; }}
    >
      {/* 車両マーカー */}
      {vehicles.map((vehicle) => (
        <Marker
          key={vehicle.id}
          position={{ lat: vehicle.latitude, lng: vehicle.longitude }}
          icon={{
            url: '/icons/truck.svg',
            scaledSize: new google.maps.Size(40, 40),
          }}
          onClick={() => onVehicleClick?.(vehicle.id)}
        />
      ))}

      {/* ルートライン */}
      {routes.map((route) => (
        <Polyline
          key={route.id}
          path={route.stops.map(stop => ({
            lat: stop.latitude,
            lng: stop.longitude,
          }))}
          options={{
            strokeColor: '#2196F3',
            strokeWeight: 3,
          }}
        />
      ))}
    </GoogleMap>
  );
};
```

## 6. セキュリティ設計

### 6.1 認証フロー
```
1. ユーザーがログインID・パスワードを入力
2. サーバーで認証情報を検証
3. JWT (Access Token + Refresh Token) を発行
4. クライアントはAccess Tokenをローカルストレージに保存
5. API呼び出し時にBearerトークンとして送信
6. サーバーでJWT検証・権限チェック
7. Access Token期限切れ時はRefresh Tokenで更新
```

### 6.2 セキュリティ対策

**SQLインジェクション対策**
- ORMのパラメータ化クエリ使用
- 入力値のバリデーション

**XSS対策**
- React のエスケープ機能活用
- Content Security Policy (CSP) 設定
- DOMPurify でユーザー入力サニタイズ

**CSRF対策**
- SameSite Cookie 設定
- CSRFトークン検証

**機密情報管理**
- 環境変数で管理（AWS Secrets Manager / Azure Key Vault）
- .envファイルは.gitignoreに追加
- APIキー・パスワードはハードコード禁止

**通信暗号化**
- HTTPS必須（TLS 1.3）
- 証明書の定期更新

**レート制限**
```typescript
// rate-limit.middleware.ts
import rateLimit from 'express-rate-limit';

export const apiLimiter = rateLimit({
  windowMs: 60 * 1000, // 1分
  max: 100, // 最大100リクエスト
  message: 'リクエスト数が上限を超えました',
});
```

## 7. パフォーマンス最適化

### 7.1 バックエンド最適化

**データベースクエリ最適化**
- N+1問題の回避（Eager Loading）
- インデックス活用
- ページネーション実装
- 集計クエリの最適化

**キャッシュ戦略**
```typescript
// cache.decorator.ts
export function Cacheable(ttl: number = 300) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const cacheKey = `${propertyKey}:${JSON.stringify(args)}`;
      const cached = await redis.get(cacheKey);

      if (cached) {
        return JSON.parse(cached);
      }

      const result = await originalMethod.apply(this, args);
      await redis.setex(cacheKey, ttl, JSON.stringify(result));
      return result;
    };

    return descriptor;
  };
}

// 使用例
@Cacheable(600) // 10分キャッシュ
async getDeliveryOrders(params: SearchParams) {
  return this.repository.find(params);
}
```

**非同期処理**
- ルート最適化はバックグラウンドジョブ化
- レポート生成は非同期実行
- メール送信は キューイング

### 7.2 フロントエンド最適化

**コード分割**
```typescript
// App.tsx
import { lazy, Suspense } from 'react';

const DeliveryOrderList = lazy(() => import('./pages/DeliveryOrderList'));
const RoutePlanning = lazy(() => import('./pages/RoutePlanning'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <Routes>
        <Route path="/orders" element={<DeliveryOrderList />} />
        <Route path="/planning" element={<RoutePlanning />} />
      </Routes>
    </Suspense>
  );
}
```

**画像最適化**
- WebP形式使用
- Lazy Loading
- CDN配信

**再レンダリング最適化**
- React.memo 活用
- useMemo / useCallback 適切な使用
- Virtual Scrolling（大量リスト表示）

## 8. 監視・ログ設計

### 8.1 アプリケーションログ

**ログレベル**
- ERROR: エラー発生時
- WARN: 警告（遅延検知等）
- INFO: 重要な処理（ログイン、配車計画確定等）
- DEBUG: デバッグ情報

**ログ出力例**
```typescript
logger.info('配送計画確定', {
  user_id: user.id,
  plan_id: plan.id,
  plan_date: plan.date,
  routes_count: plan.routes.length,
  timestamp: new Date().toISOString(),
});
```

### 8.2 監視メトリクス

**アプリケーションメトリクス**
- リクエスト数・レスポンスタイム
- エラー率
- API別のパフォーマンス
- データベース接続プール状況

**ビジネスメトリクス**
- 配送件数（日次）
- 定時配送率
- システム利用率
- 遅延発生件数

**アラート設定**
- エラー率が5%超過
- レスポンスタイムが3秒超過
- データベース接続エラー
- ディスク使用率が80%超過

## 9. デプロイ・CI/CD

### 9.1 環境構成

```
開発環境 (Dev)
  - 開発者個人のローカル環境
  - Docker Compose

ステージング環境 (Staging)
  - 本番相当の環境
  - 結合テスト・受入テスト用

本番環境 (Production)
  - 冗長化構成
  - Auto Scaling
```

### 9.2 CI/CDパイプライン

```yaml
# .github/workflows/deploy.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
      - name: Install dependencies
        run: npm ci
      - name: Run linter
        run: npm run lint
      - name: Run tests
        run: npm test
      - name: Build
        run: npm run build

  deploy-staging:
    needs: test
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Staging
        run: |
          # デプロイスクリプト実行

  deploy-production:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Production
        run: |
          # Blue-Greenデプロイ実行
```

### 9.3 Docker構成

**Dockerfile**
```dockerfile
# backend/Dockerfile
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY package*.json ./
EXPOSE 3000
CMD ["node", "dist/main.js"]
```

**docker-compose.yml**
```yaml
version: '3.8'

services:
  app:
    build: ./backend
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/delivery
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis

  db:
    image: postgis/postgis:16-3.4
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=delivery
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - app

volumes:
  postgres_data:
  redis_data:
```

## 10. 開発ガイドライン

### 10.1 コーディング規約

**命名規則**
- 変数・関数: camelCase
- クラス・型: PascalCase
- 定数: UPPER_SNAKE_CASE
- ファイル名: kebab-case

**コメント**
- 複雑なロジックには必ずコメント
- JSDoc形式で関数の説明
- TODOコメントにはチケット番号を記載

### 10.2 テスト戦略

**ユニットテスト**
- カバレッジ目標: 80%以上
- Jest使用

**統合テスト**
- APIエンドポイントのテスト
- Supertest使用

**E2Eテスト**
- 主要フローのテスト
- Playwright / Cypress使用

以上、トラック配送計画・配送実績追跡システムの技術仕様・アーキテクチャ設計でした。
